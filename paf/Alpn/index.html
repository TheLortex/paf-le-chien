<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Alpn (paf.Alpn)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">paf</a> &#x00BB; Alpn</nav><h1>Module <code>Alpn</code></h1><p>ALPN support.</p><p><code>Alpn</code> depend on <code>http/af</code> &amp; <code>h2</code> and choose them because they share the same <a href="../Paf/module-type-RUNTIME/index.html"><code>Paf.RUNTIME</code></a> interface. <code>Alpn</code> does not require <code>ocaml-tls</code> so it's possible to use OpenSSL. It requires, at least:</p><ul><li>Something to extract ALPN result from the TLS <i>flow</i></li><li>Something to represent as the string the peer (useful for over-framework)</li><li>An injection function (available from <code>mimic</code>)</li></ul><p>In other words, <code>Alpn</code> did the only choice to trust on <code>http/af</code> &amp; <code>h2</code> to handle HTTP/1.0, HTTP/1.1 and H2 protocols.</p></header><dl><dt class="spec type" id="type-protocol"><a href="#type-protocol" class="anchor"></a><code><span class="keyword">type</span> <span>('reqd, 'hdr, 'req, 'resp, 'c, 'a) protocol</span></code><code> = </code><table class="variant"><tr id="type-protocol.HTTP_1_1" class="anchored"><td class="def constructor"><a href="#type-protocol.HTTP_1_1" class="anchor"></a><code>| </code><code><span class="constructor">HTTP_1_1</span> : <span><span>(Httpaf.Reqd.t, Httpaf.Headers.t, Httpaf.Request.t, Httpaf.Response.t, <span class="type-var">'c</span>, <span><span class="type-var">'c</span> Httpaf.Body.t</span>)</span> <a href="index.html#type-protocol">protocol</a></span></code></td></tr><tr id="type-protocol.HTTP_2_0" class="anchored"><td class="def constructor"><a href="#type-protocol.HTTP_2_0" class="anchor"></a><code>| </code><code><span class="constructor">HTTP_2_0</span> : <span><span>(H2.Reqd.t, H2.Headers.t, H2.Request.t, H2.Response.t, <span class="type-var">'c</span>, <span><span class="type-var">'c</span> H2.Body.t</span>)</span> <a href="index.html#type-protocol">protocol</a></span></code></td><td class="doc"><p>Type of protocols.</p></td></tr></table></dt><dt class="spec type" id="type-body"><a href="#type-body" class="anchor"></a><code><span class="keyword">type</span> <span>'c body</span></code><code> = </code><table class="variant"><tr id="type-body.Body" class="anchored"><td class="def constructor"><a href="#type-body.Body" class="anchor"></a><code>| </code><code><span class="constructor">Body</span> : <span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">'c</span>, <span class="type-var">'v</span>)</span> <a href="index.html#type-protocol">protocol</a></span> * <span class="type-var">'v</span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> <a href="index.html#type-body">body</a></span></code></td></tr></table></dt><dt class="spec type" id="type-request"><a href="#type-request" class="anchor"></a><code><span class="keyword">type</span> request</code><code> = </code><table class="variant"><tr id="type-request.Request" class="anchored"><td class="def constructor"><a href="#type-request.Request" class="anchor"></a><code>| </code><code><span class="constructor">Request</span> : <span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">'r</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="index.html#type-protocol">protocol</a></span> * <span class="type-var">'r</span> <span>&#45;&gt;</span> <a href="index.html#type-request">request</a></code></td></tr></table></dt><dt class="spec type" id="type-response"><a href="#type-response" class="anchor"></a><code><span class="keyword">type</span> response</code><code> = </code><table class="variant"><tr id="type-response.Response" class="anchored"><td class="def constructor"><a href="#type-response.Response" class="anchor"></a><code>| </code><code><span class="constructor">Response</span> : <span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">'r</span>, <span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="index.html#type-protocol">protocol</a></span> * <span class="type-var">'r</span> <span>&#45;&gt;</span> <a href="index.html#type-response">response</a></code></td></tr></table></dt><dt class="spec type" id="type-headers"><a href="#type-headers" class="anchor"></a><code><span class="keyword">type</span> headers</code><code> = </code><table class="variant"><tr id="type-headers.Headers" class="anchored"><td class="def constructor"><a href="#type-headers.Headers" class="anchor"></a><code>| </code><code><span class="constructor">Headers</span> : <span><span>(<span class="type-var">_</span>, <span class="type-var">'hdr</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>)</span> <a href="index.html#type-protocol">protocol</a></span> * <span class="type-var">'hdr</span> <span>&#45;&gt;</span> <a href="index.html#type-headers">headers</a></code></td></tr></table></dt><dt class="spec type" id="type-resp_handler"><a href="#type-resp_handler" class="anchor"></a><code><span class="keyword">type</span> <span>'c resp_handler</span></code><code> = </code><table class="variant"><tr id="type-resp_handler.Resp_handler" class="anchored"><td class="def constructor"><a href="#type-resp_handler.Resp_handler" class="anchor"></a><code>| </code><code><span class="constructor">Resp_handler</span> : <span><span>(<span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">'r</span>, <span class="type-var">'c</span>, <span class="type-var">'v</span>)</span> <a href="index.html#type-protocol">protocol</a></span> * <span class="type-var">'r</span> * <span class="type-var">'v</span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> <a href="index.html#type-resp_handler">resp_handler</a></span></code></td></tr></table></dt><dt class="spec type" id="type-reqd_handler"><a href="#type-reqd_handler" class="anchor"></a><code><span class="keyword">type</span> <span>'c reqd_handler</span></code><code> = </code><table class="variant"><tr id="type-reqd_handler.Reqd_handler" class="anchored"><td class="def constructor"><a href="#type-reqd_handler.Reqd_handler" class="anchor"></a><code>| </code><code><span class="constructor">Reqd_handler</span> : <span><span>(<span class="type-var">'r</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">_</span>, <span class="type-var">'c</span>, <span class="type-var">'v</span>)</span> <a href="index.html#type-protocol">protocol</a></span> * <span class="type-var">'r</span> <span>&#45;&gt;</span> <span><span class="type-var">'c</span> <a href="index.html#type-reqd_handler">reqd_handler</a></span></code></td></tr></table></dt><dt class="spec type" id="type-server_error"><a href="#type-server_error" class="anchor"></a><code><span class="keyword">type</span> server_error</code> = <code>[ </code><table class="variant"><tr id="type-server_error.Bad_gateway" class="anchored"><td class="def constructor"><a href="#type-server_error.Bad_gateway" class="anchor"></a><code>| </code><code>`Bad_gateway</code></td></tr><tr id="type-server_error.Bad_request" class="anchored"><td class="def constructor"><a href="#type-server_error.Bad_request" class="anchor"></a><code>| </code><code>`Bad_request</code></td></tr><tr id="type-server_error.Exn" class="anchored"><td class="def constructor"><a href="#type-server_error.Exn" class="anchor"></a><code>| </code><code>`Exn <span class="keyword">of</span> exn</code></td></tr><tr id="type-server_error.Internal_server_error" class="anchored"><td class="def constructor"><a href="#type-server_error.Internal_server_error" class="anchor"></a><code>| </code><code>`Internal_server_error</code></td></tr></table><code> ]</code></dt><dt class="spec type" id="type-info"><a href="#type-info" class="anchor"></a><code><span class="keyword">type</span> <span>'flow info</span></code><code> = </code><code>{</code><table class="record"><tr id="type-info.alpn" class="anchored"><td class="def field"><a href="#type-info.alpn" class="anchor"></a><code>alpn : <span class="type-var">'flow</span> <span>&#45;&gt;</span> <span>string option</span>;</code></td></tr><tr id="type-info.peer" class="anchored"><td class="def field"><a href="#type-info.peer" class="anchor"></a><code>peer : <span class="type-var">'flow</span> <span>&#45;&gt;</span> string;</code></td></tr><tr id="type-info.injection" class="anchored"><td class="def field"><a href="#type-info.injection" class="anchor"></a><code>injection : <span class="type-var">'flow</span> <span>&#45;&gt;</span> Mimic.flow;</code></td></tr></table><code>}</code></dt><dd><p>The type of information from a <code>'flow</code>:</p><ul><li><code>alpn</code> is a fonction which is able to extract the result of the negotiation between the client &amp; the server about which protocol we need to start</li><li><code>peer</code> returns a <code>string</code> representation of the given <code>'flow</code> to help to print out some logs about this client.</li><li><code>injection</code> is the function which wraps the given <code>'flow</code> to a <code>Mimic.flow</code>.</li></ul><p>For the last function, it can be done if you already registered the protocol with <code>mimic</code>. In that case, the second value given by <code>Mimic.register</code> helps you to <i>inject</i> your flow as a <code>Mimic.flow</code>:</p><pre><code class="ml">let _, protocol = Mimic.register ~name:&quot;my-protocol&quot; (module My_protocol)

let injection (flow : My_protocol.flow) : Mimic.flow =
  let module R = (val Mimic.repr protocol) in
  R.T flow</code></pre></dd></dl><dl><dt class="spec value" id="val-service"><a href="#val-service" class="anchor"></a><code><span class="keyword">val</span> service : <span><span class="type-var">'flow</span> <a href="index.html#type-info">info</a></span> <span>&#45;&gt;</span> <span>error_handler:<span>(string <span>&#45;&gt;</span> <span>?&#8288;request:<a href="index.html#type-request">request</a></span> <span>&#45;&gt;</span> <a href="index.html#type-server_error">server_error</a> <span>&#45;&gt;</span> <span>(<a href="index.html#type-headers">headers</a> <span>&#45;&gt;</span> <span><span>[ `write ]</span> <a href="index.html#type-body">body</a></span>)</span> <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span>request_handler:<span>(string <span>&#45;&gt;</span> <span><span>[ `write ]</span> <a href="index.html#type-reqd_handler">reqd_handler</a></span> <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span>(<span class="type-var">'t</span> <span>&#45;&gt;</span> <span><span><span>(<span class="type-var">'flow</span>, <span>[&gt; `Closed <span><span>| `Msg</span> of string</span> ]</span> <span class="keyword">as</span> 'error)</span> Stdlib.result</span> Lwt.t</span>)</span> <span>&#45;&gt;</span> <span>(<span class="type-var">'t</span> <span>&#45;&gt;</span> <span>unit Lwt.t</span>)</span> <span>&#45;&gt;</span> <span><span class="type-var">'t</span> <a href="../Paf/index.html#type-service">Paf.service</a></span></code></dt><dd><p><code>service info ~error_handler ~request_handler accept close</code> creates a new <a href="../Paf/index.html#type-service"><code>Paf.service</code></a> over the <i>socket</i> <code>'t</code>. From the given implementation of <code>accept</code> and <code>close</code>, we are able to instantiate the <i>main loop</i>. Then, from the given <code>info</code>, we extract informations such the application layer protocol and choose which protocol we will use. Currently, if <code>info.alpn</code> returns:</p><ul><li><code>Some &quot;http/1.0&quot; | Some &quot;http/1.1&quot; | None</code>, we launch an <code>http/af</code> service</li><li><code>Some &quot;h2&quot;</code>, we launch an <code>h2</code> service</li></ul><p>The user is able to identify which protocol we launched by <code>resd_handler</code>. The returned service can be run with <a href="../Paf/index.html#val-serve"><code>Paf.serve</code></a>. Here is an example with <code>Lwt_unix.file_descr</code> and the TCP/IP transmission protocol (without ALPN negotiation):</p><pre><code class="ml">let _, protocol
  : Unix.sockaddr Mimic.value
    * (Unix.sockaddr, Lwt_unix.file_descr) Mimic.protocol
  = Mimic.register ~name:&quot;lwt-tcp&quot; (module TCP)

let accept t =
  Lwt.catch begin fun () -&gt;
    Lwt_unix.accept &gt;&gt;= fun (socket, _) -&gt;
    Lwt.return_ok socket
  end @@ function
  | Unix.Unix_error (err, f, v) -&gt;
    Lwt.return_error (`Unix (err, f, v))
  | exn -&gt; raise exn

let info =
  let module R = (val Mimic.register protocol) in
  { Alpn.alpn= const None
  ; Alpn.peer= (fun socket -&gt;
    sockaddr_to_string (Lwt_unix.getpeername socket))
  ; Alpn.injection=
    (fun socket -&gt; R.T socket) }

let service = Alpn.service info
  ~error_handler
  ~request_handler
  accept Lwt_unix.close

let fiber =
  let t = Lwt_unix.socket Unix.PF_INET Unix.SOCK_STREAM 0 in
  Lwt_unix.bind t (Unix.ADDR_INET (Unix.inet_addr_loopback, 8080))
  &gt;&gt;= fun () -&gt;
  let `Initialized th = Paf.serve
    ~sleep:(Lwt_unix.sleep &lt;.&gt; Int64.to_float)
    service t in th

let () = Lwt_main.run fiber</code></pre></dd></dl><dl><dt class="spec type" id="type-client_error"><a href="#type-client_error" class="anchor"></a><code><span class="keyword">type</span> client_error</code> = <code>[ </code><table class="variant"><tr id="type-client_error.Exn" class="anchored"><td class="def constructor"><a href="#type-client_error.Exn" class="anchor"></a><code>| </code><code>`Exn <span class="keyword">of</span> exn</code></td></tr><tr id="type-client_error.Malformed_response" class="anchored"><td class="def constructor"><a href="#type-client_error.Malformed_response" class="anchor"></a><code>| </code><code>`Malformed_response <span class="keyword">of</span> string</code></td></tr><tr id="type-client_error.Invalid_response_body_length_v1" class="anchored"><td class="def constructor"><a href="#type-client_error.Invalid_response_body_length_v1" class="anchor"></a><code>| </code><code>`Invalid_response_body_length_v1 <span class="keyword">of</span> Httpaf.Response.t</code></td></tr><tr id="type-client_error.Invalid_response_body_length_v2" class="anchored"><td class="def constructor"><a href="#type-client_error.Invalid_response_body_length_v2" class="anchor"></a><code>| </code><code>`Invalid_response_body_length_v2 <span class="keyword">of</span> H2.Response.t</code></td></tr><tr id="type-client_error.Protocol_error" class="anchored"><td class="def constructor"><a href="#type-client_error.Protocol_error" class="anchor"></a><code>| </code><code>`Protocol_error <span class="keyword">of</span> H2.Error_code.t * string</code></td></tr></table><code> ]</code></dt></dl><dl><dt class="spec value" id="val-run"><a href="#val-run" class="anchor"></a><code><span class="keyword">val</span> run : <span>sleep:<a href="../Paf/index.html#type-sleep">Paf.sleep</a></span> <span>&#45;&gt;</span> <span>?&#8288;alpn:string</span> <span>&#45;&gt;</span> <span>error_handler:<span>(<span class="type-var">'edn</span> <span>&#45;&gt;</span> <a href="index.html#type-client_error">client_error</a> <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span>response_handler:<span>(<span class="type-var">'edn</span> <span>&#45;&gt;</span> <span><span>[ `read ]</span> <a href="index.html#type-resp_handler">resp_handler</a></span> <span>&#45;&gt;</span> unit)</span></span> <span>&#45;&gt;</span> <span class="type-var">'edn</span> <span>&#45;&gt;</span> <span>[ <span>`V1 of Httpaf.Request.t</span> <span><span>| `V2</span> of H2.Request.t</span> ]</span> <span>&#45;&gt;</span> Mimic.flow <span>&#45;&gt;</span> <span><span><span>(<span><span>[ `write ]</span> <a href="index.html#type-body">body</a></span>, <span>[&gt; <span>`Msg of string</span> ]</span>)</span> Stdlib.result</span> Lwt.t</span></code></dt><dd><p><code>run ~sleep ?alpn ~error_handler ~response_handler edn req flow</code> tries communitate to <code>edn</code> via <code>flow</code> with a certain protocol according to the given <code>alpn</code> value and the given request. It returns the body of the request to allow the user to write on it (and communicate then with the server).</p><p><code>run</code> does only the ALPN dispatch. It does not instantiate the connection and it does not try to upgrade the protocol. It just choose the right HTTP protocol according to:</p><ul><li>the given <code>alpn</code> value</li><li>the given <code>request</code> (if you want to communicate via HTTP/1.1 or H2)</li></ul><p>Here is an example with <code>mimic</code>:</p><pre><code class="ml">let run uri request =
  let ctx = ctx_of_uri uri in
  (* See Mimic for more details. *)
  Mimic.resolve ctx &gt;&gt;= function
  | Error _ as err -&gt; Lwt.return err
  | Ok flow -&gt;
      run
        ~sleep:(Lwt_unix.sleep &lt;.&gt; Int64.to_float)
        ?alpn:None ~error_handler ~response_handler uri request flow</code></pre></dd></dl></div></body></html>