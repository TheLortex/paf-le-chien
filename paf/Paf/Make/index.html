<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Make (paf.Paf.Make)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">paf</a> &#x00BB; <a href="../index.html">Paf</a> &#x00BB; Make</nav><h1>Module <code>Paf.Make</code></h1></header><h3 class="heading">Parameters</h3><ul><li><code>Time : Mirage_time.S</code></li><li><code>Stack : Mirage_stack.V4V6</code></li></ul><h3 class="heading">Signature</h3><dl><dt class="spec exception" id="exception-Error"><a href="#exception-Error" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Error</span> <span class="keyword">of</span> Mimic.error</code></dt></dl><dl><dt class="spec type" id="type-stack"><a href="#type-stack" class="anchor"></a><code><span class="keyword">type</span> stack</code><code> = <a href="index.html#argument-2-Stack">Stack</a>.t</code></dt><dt class="spec type" id="type-service"><a href="#type-service" class="anchor"></a><code><span class="keyword">type</span> service</code></dt><dd><p>The type of services.</p></dd></dl><dl><dt class="spec value" id="val-init"><a href="#val-init" class="anchor"></a><code><span class="keyword">val</span> init : <span>port:int</span> <span>&#45;&gt;</span> <a href="index.html#argument-2-Stack">Stack</a>.t <span>&#45;&gt;</span> <span><a href="index.html#type-service">service</a> Lwt.t</span></code></dt><dd><p><code>init ~port stack</code> returns a <a href="index.html#type-service"><code>service</code></a> bound on <code>port</code> with <code>stack</code>.</p></dd></dl><dl><dt class="spec value" id="val-http"><a href="#val-http" class="anchor"></a><code><span class="keyword">val</span> http : <span>?&#8288;config:Httpaf.Config.t</span> <span>&#45;&gt;</span> <span>?&#8288;stop:Lwt_switch.t</span> <span>&#45;&gt;</span> <span>error_handler:<span>(<span>(Ipaddr.t * int)</span> <span>&#45;&gt;</span> Httpaf.Server_connection.error_handler)</span></span> <span>&#45;&gt;</span> <span>request_handler:<span>(<span>(Ipaddr.t * int)</span> <span>&#45;&gt;</span> Httpaf.Server_connection.request_handler)</span></span> <span>&#45;&gt;</span> <a href="index.html#type-service">service</a> <span>&#45;&gt;</span> <span>[ <span>`Initialized of <span>unit Lwt.t</span></span> ]</span></code></dt><dd><p><code>http ?config ?stop ~error_handler ~request_handler service</code> promises a service loop computation that is ready to receive connections. The inner promise is then determined once the service loop has ended - by default, only when an error occurs.</p><p>If passed, <code>stop</code> is a switch that terminates the service loop, for example to limit execution time to 10 seconds:</p><pre><code class="ml">let* service = init ~port:80 stack in
let stop = Lwt_switch.create () in
let `Initialized server = http ~stop ... service in
Lwt.both (Lwt_unix.sleep 10. &gt;&gt;= fun () -&gt; Lwt_switch.turn_off stop) server</code></pre><p>This is useful when subsequent actions are reliant on the service loop having begin, such as when testing with a client-server pair:</p><pre><code class="ml">let* service = init ~port:80 stack in
let `Initialized server = http ... service in
Lwt.both server (client &gt;|= signal_stop)</code></pre></dd></dl><dl><dt class="spec value" id="val-https"><a href="#val-https" class="anchor"></a><code><span class="keyword">val</span> https : <span>tls:Tls.Config.server</span> <span>&#45;&gt;</span> <span>?&#8288;config:Httpaf.Config.t</span> <span>&#45;&gt;</span> <span>?&#8288;stop:Lwt_switch.t</span> <span>&#45;&gt;</span> <span>error_handler:<span>(<span>(Ipaddr.t * int)</span> <span>&#45;&gt;</span> Httpaf.Server_connection.error_handler)</span></span> <span>&#45;&gt;</span> <span>request_handler:<span>(<span>(Ipaddr.t * int)</span> <span>&#45;&gt;</span> Httpaf.Server_connection.request_handler)</span></span> <span>&#45;&gt;</span> <a href="index.html#type-service">service</a> <span>&#45;&gt;</span> <span>[ <span>`Initialized of <span>unit Lwt.t</span></span> ]</span></code></dt><dd><p>Same as <a href="index.html#val-http"><code>http</code></a>, but requires a TLS certificate <code>tls</code>.</p></dd></dl><dl><dt class="spec value" id="val-tcp_edn"><a href="#val-tcp_edn" class="anchor"></a><code><span class="keyword">val</span> tcp_edn : <span><span>(<a href="index.html#argument-2-Stack">Stack</a>.t * Ipaddr.t * int)</span> Mimic.value</span></code></dt><dt class="spec value" id="val-tls_edn"><a href="#val-tls_edn" class="anchor"></a><code><span class="keyword">val</span> tls_edn : <span><span>(<span><span><span>[ `host ]</span> Domain_name.t</span> option</span> * Tls.Config.client * <a href="index.html#argument-2-Stack">Stack</a>.t * Ipaddr.t * int)</span> Mimic.value</span></code></dt><dt class="spec value" id="val-request"><a href="#val-request" class="anchor"></a><code><span class="keyword">val</span> request : <span>?&#8288;config:Httpaf.Config.t</span> <span>&#45;&gt;</span> <span>ctx:Mimic.ctx</span> <span>&#45;&gt;</span> <span>error_handler:<span>(Mimic.flow <span>&#45;&gt;</span> <span><span>(Ipaddr.t * int)</span> option</span> <span>&#45;&gt;</span> Httpaf.Client_connection.error_handler)</span></span> <span>&#45;&gt;</span> <span>response_handler:<span>(<span><span>(Ipaddr.t * int)</span> option</span> <span>&#45;&gt;</span> Httpaf.Client_connection.response_handler)</span></span> <span>&#45;&gt;</span> Httpaf.Request.t <span>&#45;&gt;</span> <span><span><span>(<span><span>[ `write ]</span> Httpaf.Body.t</span>, <span>[&gt; Mimic.error ]</span>)</span> Stdlib.result</span> Lwt.t</span></code></dt><dd><p><code>request ?config ~ctx ~error_handler ~response_handler req</code> returns a <i>open</i> HTTP body according to the given context <code>ctx</code> and the request <code>req</code>.</p><p>To be able to start a simple HTTP connection, you must:</p><ul><li>know the target IP address</li><li>create the client <i>stack</i></li><li>know the target port (default to <code>80</code>)</li></ul><p>These values must exist into the given <code>ctx</code> to, at least, be able to start a TCP/IP connection:</p><pre><code class="ml">let ctx =
  Mimic.add Paf.tcp_edn
    (stack, ipaddr_of_google, 80)
    Mimic.empty Paf.request ~ctx ~error_handler ~response_handler req</code></pre><p>The user is able to fill the <code>ctx</code> with some clever processes such as a DNS resolver:</p><pre><code class="ml">let domain_name = Mimic.make ~name:&quot;domain-name&quot;

let ipaddr = Mimic.make ~name:&quot;ipaddr&quot;

let resolver domain_name =
  match Unix.gethostbyname (Domain_name.to_string domain_name) with
  | { Unix.h_addr_list; _ } -&gt;
      if Array.length h_addr_list &gt; 0
      then Lwt.return_some (Ipaddr_unix.of_inet_addr h_addr_list.(0))
      else Lwt.return_none
  | exception _ -&gt; Lwt.return_none

let stack = Mimic.make ~name:&quot;stack&quot;

let port = Mimic.make ~name:&quot;port&quot;

let connect stack ipaddr port = Lwt.return_some (stack, ipaddr, port)

let ctx =
  let open Mimic in
  fold ipaddr Fun.[ req domain_name ] ~k:resolver Mimic.empty
  |&gt; fold Paf.tcp_edn
       Fun.[ req stack; req ipaddr; dft port 80 ]
       ~k:connect</code></pre><p>If <code>mimic</code> is able to create a <a href="index.html#val-tcp_edn"><code>tcp_edn</code></a> value from the <code>ctx</code> and these functions, the user will be able to start a TCP/IP connection. <code>ipaddr</code> will come from a given <code>domain_name</code> and if the <code>port</code> is missing, we use <code>80</code> as the default value. The <code>stack</code> still is required.</p><p>For a more user-friendly interface, you should take a look into <code>paf.cohttp</code>.</p></dd></dl></div></body></html>